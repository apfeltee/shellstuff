#!/usr/bin/env ruby

# BIG FAT WARNING:
# you ***HAVE TO*** modify 'CYGWIN_TEMP_DIRECTORY' to reflect the directory
# where cygwin has downloaded its temporary files!

CYGWIN_TEMP_DIRECTORY = "/downloaded"

class CygPackages
  def initialize(args)
    @setupinis = nil
    @localconf = File.join(ENV["HOME"], "/.cygpackages.yml")
    @args = args
    @progname = File.basename($0)
    we_just_updated = false
    # force update if our local config doesn't exist yet
    if not File.file?(@localconf) then
      update(true)
      we_just_updated = true
    end
    # check commandline args...
    if args.length > 0 then
      args.each do |arg|
        case arg
          when "-h", "--help" then
            print_usage
            exit
          when "-a", "--all"
            confdata = get_localconf
            confdata.each do |pkgname, data|
              print_data(pkgname, data)
            end
            exit
          when "-u", "--update" then
            if we_just_updated then
              $stderr.puts("#@progname: won't update again because we just updated!")
              $stderr.puts("#@progname: delete '#@localconf' and rerun #@progname if you mean it.")
            else
              update(true)
            end
            args.shift
          else
            if arg.start_with?("-") then
              $stderr.puts "#@progname: unknown option '#{arg}'"
              exit
            end
        end
      end
      exit if (args.length == 0)
      # if we've reached this point, then user has given terms to search for
      success = false
      $stderr.puts("Searching for each of #{args.map{|s| Regexp.new(s)}} ... ")
      confdata = get_localconf
      pkgcount = confdata.size
      args.each do |findme|
        rx = Regexp.new(findme)
        confdata.each do |pkgname, data|
          if is_match(rx, pkgname, data) then
            print_data(pkgname, data)
            success = true
          end
        end
      end
      if not success then
        $stderr.puts("nothing found (searched #{pkgcount} packages)")
      end
    else
      print_usage
    end
  end

  def print_usage
    puts [
      "'#@progname' queries available packages",
      "",
      "Usage:",
      "  #@progname [<option>] <pattern(s) ...>   # will list packages that match <pattern(s)>",
      "",
      "Note that both the package name, as well as the description is compared (ignoring case-sensitivity)!",
      "",
      "<option> can be any of these:",
      "   -h | --help        show this help and exit",
      "   -u | --update      force a fresh update of '#@localconf'",
      "   -a | --all         print EVERY package found in '#@localconf' (VERBOSE!)",
      "\n",
    ].join("\n")
  end

  def is_match(rx, pkgname, data)
    name = pkgname.downcase
    desc = data[:description].downcase
    if (name.match(rx) || desc.match(rx)) then
      return true
    end
    return false
  end

  def print_data(pkgname, data)
    description = data[:description]
    $stdout.puts("%-40s: %s\n" % [pkgname, description])
    $stdout.flush
  end

  def get_localconf
    if File.file?(@localconf) then
      require "yaml"
      return YAML.load(File.read(@localconf))
    else
      $stderr.puts "Local config '#@localconf' doesn't exist! Did you forget to update?"
      exit
    end
  end

  def get_inifiles
    all = []
    if File.directory?(CYGWIN_TEMP_DIRECTORY) then
      Dir.entries(CYGWIN_TEMP_DIRECTORY).each do |path|
        next if ((path == ".") || (path == ".."))
        realpath = File.join(CYGWIN_TEMP_DIRECTORY, path)
        all += Dir.glob(File.join(realpath, "*/setup.ini"))
      end
    else
      $stderr.puts "#@program: 'CYGWIN_TEMP_DIRECTORY' (aka #{CYGWIN_TEMP_DIRECTORY.inspect}) is not a directory!"
      exit
    end
    if all.length == 0 then
      $stderr.puts "#@program: not a single setup.ini was found! Is CYGWIN_TEMP_DIRECTORY set correctly?"
      exit
    end
    return all
  end

  def update(force = false)
    @setupinis = get_inifiles
    @shortdesc_name = "sdesc:"
    if (force == true) && File.file?(@localconf) then
      File.unlink(@localconf)
    end
    $stderr.puts("will update '#@localconf' now ...")
    File.open(@localconf, "wb") do |fh|
      fh.puts("# DO NOT EDIT!")
      fh.puts("# this file was automatically generated by #@progname.")
      fh.puts
      # sure, I *could* use regular expressions. But, I can also parse it manually.
      @setupinis.each do |file|
        # easier to iterate manually
        lines = File.open(file, "rb").readlines
        # iterate over data ...
        name = nil
        (0 .. lines.length).each do |idx|
          line = lines[idx]
          if line != nil then
            # package blocks are denoted with '@', i.e., '@ some-package'
            if line.start_with?("@") then
              # remove '@' and whitespace
              name = line[1, line.length].strip
              # scan for next line that usually (hopefully) includes 'sdesc', i.e.,
              # the short description
              if lines[idx + 1].start_with?(@shortdesc_name) then
                # remove whitespace
                rawdesc = lines[idx + 1].strip
                # get rid of 'sdesc:' and whitespace
                desc = rawdesc[@shortdesc_name.length , rawdesc.length].strip
                # remove the doublequotes
                desc = desc[1, desc.length - 2]
                # all done!
                fh.puts(":%s:\n    :description: %s\n\n" % [name, desc.inspect])
              end
            end
          end
        end
      end
      fh.puts("\n")
    end
  end
end

CygPackages.new(ARGV)
