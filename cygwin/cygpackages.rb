#!/usr/bin/ruby --disable-gems

require "ostruct"
require "optparse"
require "yaml"

# BIG FAT WARNING:
# you ***HAVE TO*** modify 'cygtempdir' to reflect the directory
# where cygwin has downloaded its temporary files!

CYGWIN_SETUPRCFILE = "/etc/setup/setup.rc"

class CygPackages
  def initialize
    @setupinis = nil
    @localconf = File.join(ENV["HOME"], "/.cygpackages.yml")
    @progname = File.basename($0)
    @we_just_updated = false
  end

  def main(prs, args, opts)
    # force update if our local config doesn't exist yet
    update(true) unless File.file?(@localconf)
    if opts.want_update then
      if (@we_just_updated == false)
        update(true)
      end
    end
    if args.length > 0 then
      # if we've reached this point, then user has given terms to search for
      success = false
      rexes = args.map{|s| Regexp.new(s, Regexp::IGNORECASE)}
      $stderr.puts("Searching for each of #{rexes} ... ")
      confdata = get_localconf
      pkgcount = confdata.size
      rexes.each do |rx|
        confdata.each do |pkgname, data|
          if is_match(rx, pkgname, data) then
            print_data(pkgname, data)
            success = true
          end
        end
      end
      if not success then
        $stderr.puts("nothing found (searched #{pkgcount} packages)")
      end
    else
      puts(prs.help)
    end
  end


  def is_match(rx, pkgname, data)
    name = pkgname.downcase
    desc = data[:description].downcase
    if (name.match(rx) || desc.match(rx)) then
      return true
    end
    return false
  end

  def print_data(pkgname, data)
    description = data[:description]
    $stdout.puts("%-40s: %s\n" % [pkgname, description])
    $stdout.flush
  end

  def get_localconf
    if File.file?(@localconf) then
      return YAML.load(File.read(@localconf))
    else
      $stderr.printf("Local config %p doesn't exist! Did you forget to update?\n", @localconf)
      exit
    end
  end

  def get_inifiles
    all = []
    if File.file?(CYGWIN_SETUPRCFILE) then
      # get cache path from setup.rc
      cygtempdir = File.read("/etc/setup/setup.rc", 512).scan(/last-cache\n\t.*\n/).first.split(/\t/)[1].strip
      # transform path from "c:\somepath\whatever" to "c:/somepath/whatever", because
      # mixing backward and forward slashes yields invalid paths
      cygtempdir.gsub!(/\\/, "/")
      if cygtempdir && File.directory?(cygtempdir) then
        Dir.entries(cygtempdir).each do |path|
          next if ((path == ".") || (path == ".."))
          realpath = File.join(cygtempdir, path)
          all += Dir.glob(File.join(realpath, "/*/setup.ini"))
        end
      else
        $stderr.printf("error: 'cygtempdir' %p is not a directory!\n", cygtempdir)
        exit
      end
      if all.length == 0 then
        $stderr.printf("error: not a single setup.ini was found! is cygtempdir (aka %p) set correctly?\n", cygtempdir)
        exit
      end
      return all
    else
      $stderr.printf("error: CYGWIN_SETUPRCFILE (aka %p) does not exist!\n", CYGWIN_SETUPRCFILE)
      exit
    end
  end

  def update(force = false)
    totaluniq = 0
    totalpkgs = 0
    @setupinis = get_inifiles
    @shortdesc_name = "sdesc:"
    if (force == true) && File.file?(@localconf) then
      File.unlink(@localconf)
    end
    $stderr.puts("will update '#@localconf' now ...")
    File.open(@localconf, "wb") do |fh|
      seen = []
      fh.puts("# DO NOT EDIT!")
      fh.puts("# this file was automatically generated by cygpackes.rb")
      fh.puts
      # sure, I *could* use regular expressions. But, I can also parse it manually.
      @setupinis.each do |file|
        pkgcount = 0
        # uniqcount is not actually used yet...
        uniqcount = 0
        $stderr.printf(" reading from %p ...\n", file)
        # have to read the file in as lines, because due to cygwin's
        # funky package list syntax, lines are context sensitive
        lines = File.open(file, "rb").readlines
        # iterate over data ...
        name = nil
        (0 .. lines.length).each do |idx|
          line = lines[idx]
          if line != nil then
            # package blocks are denoted with '@', i.e., '@ some-package'
            if line.start_with?("@") then
              # remove '@' and whitespace
              name = line[1, line.length].strip
              if not seen.include?(name) then
                seen.push(name)
                # scan for next line that usually (hopefully) includes 'sdesc', i.e.,
                # the short description
                if lines[idx + 1].start_with?(@shortdesc_name) then
                  # remove whitespace
                  rawdesc = lines[idx + 1].strip
                  # get rid of 'sdesc:' and whitespace
                  desc = rawdesc[@shortdesc_name.length , rawdesc.length].strip
                  # remove the doublequotes
                  desc = desc[1, desc.length - 2]
                  # all done!
                  fh.puts(":#{name}:\n    :description: #{desc.inspect}\n\n")
                  pkgcount += 1
                end
              end
            end
          end
        end
        $stderr.printf("  retrieved %d packages\n", pkgcount)
        totalpkgs += pkgcount
      end
      fh.puts("\n")
      $stderr.printf("total count: %d unique packages (%d packages)\n", totaluniq, totalpkgs)
    end
    @we_just_updated = true
  end
end

begin
  opts = OpenStruct.new
  cygp = CygPackages.new
  prs = OptionParser.new{|prs|
    prs.on("-u", "--update", "update local configuration"){|_|
      opts.want_update = true
    }
  }
  prs.parse!
  cygp.main(prs, ARGV, opts)
end